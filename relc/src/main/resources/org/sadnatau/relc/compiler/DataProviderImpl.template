package org.sadnatau.relc.compiler;

import org.sadnatau.relc.data.DataProvider;
import org.sadnatau.relc.util.SemanticError;
import org.sadnatau.relc.util.ToolBox;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * Class generated by RelC compiler,
 * and is an implementation of the relational interface.
 *
 */
public class CompilerOutputCore implements DataProvider {

	private String decompositionSerializationFilePath;
	private String cols;
	private String funDomCols;
	private String funImgCols;

	// set of columns.
	private List<String> columns;

	// set of columns of domain of relation spec. function.
	private List<String> funcDomainCols;

	// set of columns of image of relation spec. function.
	private List<String> funcImageCols;

	// the decomposition graph.s
	private DecompositionGraph decompGraph;

	// root of decomposition instance.
	private InstanceNode root;


	/**
	 *
	 * Default constructor.
	 *
	 */

	// filling columns list and lists of fun. domain and image columns.
	private void initColumnsAndFunction() {

		this.columns = new ArrayList<String>();
		String[] arr = this.cols.split(",");
        Collections.addAll(this.columns, arr);

		this.funcDomainCols = new ArrayList<String>();
		arr = this.funDomCols.split(",");
        Collections.addAll(this.funcDomainCols, arr);

		this.funcImageCols = new ArrayList<String>();
		arr = this.funImgCols.split(",");
        Collections.addAll(this.funcImageCols, arr);

	}

	// filling decomposition graph using serialization.
	private void initDecompositionGraph() throws IOException, ClassNotFoundException {

		ObjectInputStream in = null;
		try {
			in = new ObjectInputStream(new FileInputStream(this.decompositionSerializationFilePath));
			this.decompGraph = ((DecompositionGraph) (in.readObject()));
			in.close();
		} finally {
			try {
				if (in != null) {
					in.close();
				}

			} catch (IOException e) {
				// ignore
			}
		}
	}

    @Override
	public void empty() {

		//root is the first in topological sort.
		DecompositionGraph.Vertex rt = decompGraph.iterator().next();

		this.root = new InstanceNode(rt.getName());
	}


    @Override
	public void insert(List<String> colValues) throws SemanticError {

		if (colValues.size() != this.columns.size()) {
			throw new SemanticError("Wrong number of columns in 'insert' operation.");
		}

		List<InstanceNode> left = new ArrayList<InstanceNode>();
		left.add(this.root);

        for (DecompositionGraph.Vertex v : this.decompGraph) {

            //next vertex in top. order.
            InstanceNode curr = null;
            curr = getInstanceNodeByName(left, v.getName());  //curr. node instance (in top. order).
            if (v.isSinkVertex()) {
                List<String> sinkColVals = ToolBox.neededColValues(v.getSinkColsNames(), colValues);
                curr.addSinkNodeValues(sinkColVals);
                continue;
            }

            //not sink vertex.
            for (DecompositionGraph.Edge e : v.getAdjList()) {
                List<String> mapKeyColumns = ToolBox.neededColValues(e.getCols(), colValues);
                InstanceNode node = getInstanceNodeByName(left, e.getDestVertName());
                if (node != null) {  //we have already a copy of this node.
                    curr.addAdjacent(e.getDestVertName(), mapKeyColumns, e.getPrimitiveDS(), node);
                } else {
                    InstanceNode tmp = curr.addAdjacent(e.getDestVertName(), mapKeyColumns, e.getPrimitiveDS(), null);
                    left.add(tmp);
                }

            }
        }

	}


    @Override
	public List<List<String>> query(List<String> theQuery, List<String> outputColNames) {

		List<List<String>> tmp = this.root.queryNode(theQuery);
		List<List<String>> ret = new ArrayList<List<String>>();
        System.out.println(tmp);
		for (List<String> tup : tmp) {
			List<String> res = ToolBox.neededColValues(outputColNames, tup);
			Collections.sort(res);
			ret.add(res);
		}

		return ret;
	}

    @Override
	public void remove(List<String> tuple) {

		List<String> colsToRemove = ToolBox.getColNamesOfTuple(tuple);
		List<DecompositionGraph.Vertex> vertices = new ArrayList<DecompositionGraph.Vertex>();

		for (DecompositionGraph.Vertex v : this.decompGraph) {
			boolean aboveCut = false;
			if (!ToolBox.isSubSet(colsToRemove, v.getBoundCols())) {
				aboveCut = true;
			}
			v.setAboveCut(aboveCut);
			vertices.add(v);
		}
		this.root.removeNode(tuple, vertices);  //root is always above cut.
	}

    @Override
	public void update(List<String> matchingTuple, List<String> updateValues) throws SemanticError {

		List<String> matchTupColNames = ToolBox.getColNamesOfTuple(matchingTuple);
		List<String> valsColNames = ToolBox.getColNamesOfTuple(updateValues);

		Collections.sort(matchTupColNames);
		Collections.sort(this.funcDomainCols);

		if (!matchTupColNames.equals(this.funcDomainCols)) {
			throw new SemanticError("Matching columns in update must be the key columns of the relation.");
		}

		if (!ToolBox.isSubSet(valsColNames, this.funcImageCols)) {
			throw new SemanticError("Updating columns in update should not include key columns.");
		}

        List<List<String>> toFind = query(matchingTuple, funcImageCols); // we request as the result img. columns.
        remove(matchingTuple);

        for (List<String> t : toFind) {
				ToolBox.updateTuple(t, updateValues);
				List<String> toInsert = ToolBox.setsUnion(matchingTuple, t);
				insert(toInsert);
		}
	}

	/* (non-Javadoc)
	 * @see java.lang.Object#toString()
	 */
	@Override
	public String toString() {
		return this.root.toString();
	}


	private InstanceNode getInstanceNodeByName(List<InstanceNode> lst, String nameToFind) {
		for (InstanceNode el : lst) {
			if (el.getName().equals(nameToFind)) {
				return el;
			}
		}
		return null;
	}
}
